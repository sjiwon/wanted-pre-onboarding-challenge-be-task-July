Nê°œì˜ Threadê°€ ë™ì‹œì— ê°™ì€ DB Table Rowë¥¼ ì—…ë°ì´íŠ¸í•˜ëŠ” ê²½ìš° ë°œìƒí•  ìˆ˜ ìˆëŠ” ëŒ€í‘œì ì¸ ë¬¸ì œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤

### 1. Lost Update
```sql
-- Transaction 1
UPDATE member SET age = 20 WHERE id = 1;
COMMIT;

-- Transaction 2
UPDATE member SET age = 24 WHERE id = 1;
COMMIT;
```

T1 & T2 ëª¨ë‘ `id = 1`ì— ëŒ€í•œ Rowë¥¼ Updateí•˜ê³  ìˆë‹¤
- í•˜ì§€ë§Œ ìœ„ì™€ ê°™ì€ ìˆœì„œë¡œ ì§„í–‰ë  ê²½ìš° ìµœì¢…ì ìœ¼ë¡œ `id = 1 -> age = 24`ë¡œ updateëœë‹¤
- ë”°ë¼ì„œ Transaction 1ì˜ ë³€ê²½ ì‚¬í•­ì´ ì—†ì–´ì§€ëŠ” `Lost Update`ë¬¸ì œê°€ ë°œìƒí•œë‹¤
  - T1ì˜ ì…ì¥ì—ì„œëŠ” ë³¸ì¸ì´ ë°˜ì˜í•œ `age = 20`ì´ ì—†ì–´ì§€ê²Œ ë˜ëŠ” ê²ƒì´ë‹¤

### 2. Dirty Read
```sql
-- default age = 100

-- Transaction 1
UPDATE member SET age = 20 WHERE id = 1;

-- Transaction 2
SELECT age FROM member WHERE id = 1;
// age = 20ì´ë¼ëŠ” ë°ì´í„°ë¥¼ ê°€ì§€ê³  ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ ì§„í–‰
COMMIT;

-- Transaction 1
ROLLBACK;
```

> Isolation Level = READ UNCOMMITTEDë¼ê³  ê°€ì •

Isolation Levelì´ `Read Uncommitted`ì´ë¯€ë¡œ T2ëŠ” T1ì´ ì•„ì§ ì»¤ë°‹í•˜ì§€ ì•Šì€ ë°ì´í„°ì¸ `age = 20`ì„ ì½ëŠ”ë‹¤
- `ì–¸ë‘ ë¡œê·¸`ê°€ ì•„ë‹Œ `InnoDB ë²„í¼ í’€ ë°ì´í„°`ë¥¼ ë‹¤ì´ë ‰íŠ¸ë¡œ Access

ì´í›„ T2ëŠ” `age = 20`ì¸ ë°ì´í„°ë¥¼ ê°€ì§€ê³  ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì„ ì§„í–‰í•œ í›„ Commitì„ í•˜ì˜€ë‹¤

í•˜ì§€ë§Œ ê·¸ í›„ T1ì´ `age = 20`ì„ Rollbackí•¨ìœ¼ë¡œì¨ ìµœì¢… DB ë°ì´í„°ëŠ” `age = 100`ìœ¼ë¡œ ì›ìƒë³µêµ¬ë˜ê³  T2ê°€ ì§„í–‰í•œ ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì€ ê²°êµ­ ìœ íš¨í•˜ì§€ ì•Šì€ ë°ì´í„°ë¥¼ ê°€ì§€ê³  ì²˜ë¦¬ë¨ì„ í™•ì¸í•  ìˆ˜ ìˆë‹¤


<hr>

> ì•ìœ¼ë¡œ ì„¤ëª…í•  ì˜ˆì œëŠ” `Spring Boot + JPA + MySQL + Redis` í™˜ê²½ì„ ê¸°ì¤€ìœ¼ë¡œ ì„¤ëª…
- [ì˜ˆì œ ë ˆí¬](https://github.com/sjiwon/wanted-july-concurrency)

# 1. synchronized
ìë°”ì—ì„œ ì œê³µí•´ì£¼ëŠ” `synchronized í‚¤ì›Œë“œ`ëŠ” `Monitor Lock` ë©”ì»¤ë‹ˆì¦˜ì„ í†µí•´ì„œ `Critical Sectionì— ëŒ€í•œ Race Condition ë¬¸ì œ`ë¥¼ í•´ê²°í•œë‹¤

```java
// Ticket Domain
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Entity
@Table(name = "ticket")
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private int amount;

    public Ticket(String name, int amount) {
        this.name = name;
        this.amount = amount;
    }

    public void buyTicket() {
        validateTicketRemains();
        amount--;
    }

    private void validateTicketRemains() {
        if (amount == 0) {
            throw WantedConcurrencyException.type(TicketException.TICKET_NOT_ENOUGH);
        }
    }
}

// Service
@Service
@RequiredArgsConstructor
public class TicketServiceWithSynchronized {
    private final TicketRepository ticketRepository;

    public synchronized void buy(String ticketName) {
        // 1. get Ticket
        Ticket ticket = ticketRepository.findByName(ticketName);

        // 2. buy
        ticket.buyTicket();

        // 3. apply
        ticketRepository.saveAndFlush(ticket);

        // 4. logging remain tickets
        TicketHelper.loggingTicketBuyProcess(ticket);
    }
}

// Test Code
@BeforeEach
void setUp() {
    ticketRepository.save(new Ticket(TICKET_NAME, 100));
}

@Test
@DisplayName("100ëª…ì˜ ì‚¬ìš©ìê°€ ë‚¨ì€ í‹°ì¼“ 100ì¥ì„ í•œì¥ì”© êµ¬ë§¤í•œë‹¤ [With Synchronized]")
void buyTicketWithSynchronized() throws InterruptedException {
    // given
    final ExecutorService executorService = Executors.newFixedThreadPool(THREAD_COUNT);
    final CountDownLatch countDownLatch = new CountDownLatch(THREAD_COUNT);

    // when
    for (int i = 0; i < THREAD_COUNT; i++) {
        executorService.submit(() -> {
            try {
                ticketServiceWithSynchronized.buy(TICKET_NAME);
            } catch (Exception e) {
                log.error(e.getMessage());
            } finally {
                countDownLatch.countDown();
            }
        });
    }
    countDownLatch.await();

    // then
    assertThat(getAuctionRecordCount()).isEqualTo(0);
}

private int getAuctionRecordCount() {
    return em.createQuery(
                    "SELECT t.amount" +
                            " FROM Ticket t" +
                            " WHERE t.name = :ticketName",
                    Integer.class
            )
            .setParameter("ticketName", TICKET_NAME)
            .getSingleResult();
}
```
![image](https://github.com/sjiwon/wanted-pre-onboarding-challenge-be-task-July/assets/51479381/0f1da137-1ee8-4f1b-a613-a98cad565a00)

## ğŸ”¥ë¬¸ì œì 
synchronizedëŠ” ë‹¨ì¼ ì¸ìŠ¤í„´ìŠ¤ì—ì„œì˜ ë™ì‹œì„±ì€ í•´ê²°í•  ìˆ˜ ìˆë‹¤
- í•˜ì§€ë§Œ ì„œë²„ ìì²´ê°€ ë¶„ì‚°ëœ í™˜ê²½ì´ë¼ë©´?

ê·¸ë¦¬ê³  ì¶”ê°€ì ìœ¼ë¡œ ìœ„ì™€ ê°™ì´ synchronizedë¥¼ ì ìš©í•˜ê²Œ ë˜ë©´ `TicketServiceWithSynchronized - buy()`ë ˆë²¨ì— Monitor Lockì´ ê±¸ë¦¬ê¸° ë•Œë¬¸ì— ìƒìš© ì• í”Œë¦¬ì¼€ì´ì…˜ì—ì„œì˜ ë™ì‹œì„± ì²˜ë¦¬ ì„±ëŠ¥ì€ í¬ê²Œ ì €í•˜ëœë‹¤

> [ê´€ë ¨ í¬ìŠ¤íŒ…](https://sjiwon-dev.tistory.com/20)

<br>

# 2. DB Lock (Pessimistic Lock & Optimistic Lock & Named Lock)

## Pessimistic Lock

> íŠ¸ëœì­ì…˜ê°„ì— ì¶©ëŒì´ ë°œìƒí•  ê²ƒì´ë¼ê³  ê°€ì •í•˜ê³  `DB ë ˆë²¨ì˜ Lock`ì„ í†µí•´ì„œ ë™ì‹œì„±ì„ ì²˜ë¦¬í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜

- Pessimistic Write Lock(X-Lock)ì˜ ê²½ìš° í™•ì‹¤í•œ ë™ì‹œì„± ì²˜ë¦¬ ë³´ì¥
  - S-Lockì˜ ê²½ìš° `Read Operation`ìì²´ê°€ ê°€ëŠ¥í•˜ê¸° ë•Œë¬¸ì— ë°ì´í„° ë¶ˆì¼ì¹˜ ë°œìƒ ê°€ëŠ¥

### ì¥ì 
- ì¶©ëŒì´ ìì£¼ ë°œìƒí•˜ëŠ” í™˜ê²½ì—ì„œëŠ” Retry Logicì— ëŒ€í•œ ë¶€ë‹´ì´ ì—†ê¸° ë•Œë¬¸ì— ì„±ëŠ¥ìƒ ìœ ë¦¬í•˜
- ë°ì´í„° ë¬´ê²°ì„±ì„ ë³´ì¥í•˜ëŠ” ìˆ˜ì¤€ì´ ë†’ë‹¤

### ë‹¨ì 
- ì¼ë°˜ì ì¸ ê²½ìš° ë™ì‹œ ì²˜ë¦¬ ì„±ëŠ¥ì´ ë§ì´ ì €í•˜ëœë‹¤
- Deadlock ë°œìƒ ê°€ëŠ¥

```java
// Repository
public interface TicketRepository extends JpaRepository<Ticket, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT t FROM Ticket t WHERE t.name = :ticketName")
    Ticket findByNameWithPessimisticLock(@Param("ticketName") String ticketName);
}

// Service
@Service
@RequiredArgsConstructor
public class TicketServiceWithPessimisticLock {
    private final TicketRepository ticketRepository;

    @Transactional
    public void buy(String ticketName) {
        // 1. get Ticket
        Ticket ticket = ticketRepository.findByNameWithPessimisticLock(ticketName);

        // 2. buy
        ticket.buyTicket();

        // 3. logging remain tickets
        TicketHelper.loggingTicketBuyProcess(ticket);
    }
}
```

![image](https://github.com/sjiwon/wanted-pre-onboarding-challenge-be-task-July/assets/51479381/3dfcf883-f4ed-4802-8609-ea942214cd49)


## Optimistic Lock

> íŠ¸ëœì­ì…˜ê°„ì— ì¶©ëŒì´ ë°œìƒí•˜ì§€ ì•Šì„ê²ƒì´ë¼ê³  ê°€ì •í•˜ê³  `Application ë ˆë²¨ì—ì„œì˜ Version`ì„ í†µí•´ì„œ ë™ì‹œì„±ì„ ì²˜ë¦¬í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜

### ì¥ì 
- DB ë ˆë²¨ì— Lockì„ ê±¸ì§€ ì•Šê¸° ë•Œë¬¸ì— Pessimistic Lockì— ë¹„í•´ ì„±ëŠ¥ì´ ì¢‹ë‹¤

### ë‹¨ì 
- ì¦ì€ ì¶©ëŒì´ ë°œìƒí•œë‹¤ë©´ Retryì— ëŒ€í•œ ë¶€ë‹´ì´ ì‹¬í•´ì§„ë‹¤
- ì¶©ëŒì´ ë°œìƒí–ˆì„ ê²½ìš° Application Levelì—ì„œì˜ Retry ì „ëµì„ êµ¬í˜„í•´ì•¼ í•œë‹¤

```java
// Ticket Domain
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Entity
@Table(name = "ticket")
public class Ticket {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String name;

    private int amount;

    @Version
    private Long version;

    public Ticket(String name, int amount) {
        this.name = name;
        this.amount = amount;
    }

    public void buyTicket() {
        validateTicketRemains();
        amount--;
    }

    private void validateTicketRemains() {
        if (amount == 0) {
            throw WantedConcurrencyException.type(TicketException.TICKET_NOT_ENOUGH);
        }
    }
}

// Facade
@Slf4j
@Service
@RequiredArgsConstructor
public class TicketFacadeWithOptimisticLock {
    private final TicketServiceWithOptimisticLock ticketServiceWithOptimisticLock;

    public void buy(String ticketName) throws InterruptedException {
        while (true) {
            try {
                ticketServiceWithOptimisticLock.buy(ticketName);
                break;
            } catch (Exception e) {
                TicketHelper.loggingOptimisticException();
                Thread.sleep(50); // 50ms ëŒ€ê¸° í›„ Retry
            }
        }
    }
}

// Repository
public interface TicketRepository extends JpaRepository<Ticket, Long> {
    @Lock(LockModeType.OPTIMISTIC)
    @Query("SELECT t FROM Ticket t WHERE t.name = :ticketName")
    Ticket findByNameWithOptimisticLock(@Param("ticketName") String ticketName);
}

// Service
@Service
@RequiredArgsConstructor
public class TicketServiceWithOptimisticLock {
    private final TicketRepository ticketRepository;

    @Transactional
    public void buy(String ticketName) {
        // 1. get Ticket
        Ticket ticket = ticketRepository.findByNameWithOptimisticLock(ticketName);

        // 2. buy
        ticket.buyTicket();

        // 3. logging remain tickets
        TicketHelper.loggingTicketBuyProcess(ticket);
    }
}
```
![image](https://github.com/sjiwon/wanted-pre-onboarding-challenge-be-task-July/assets/51479381/3a9ae52c-81f9-4e59-a248-0c2a18e4969a)

- JPAì—ì„œëŠ” `@Version`ì„ í†µí•´ì„œ Optimistic Lockì„ êµ¬í˜„í•œë‹¤
- Facade Layerì—ì„œ ê°„ë‹¨í•˜ê²Œ Retryì— ëŒ€í•œ ë¡œì§ êµ¬í˜„


## Named Lock
> ì„ì˜ì˜ ë¬¸ìì—´ì„ í†µí•´ì„œ Lockì„ ê´€ë¦¬í•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜
- User-Level Lock

```java
// Repository
public interface TicketRepository extends JpaRepository<Ticket, Long> {
    @Query(value = "SELECT GET_LOCK(:key, 10)", nativeQuery = true)
    void getLock(@Param("key") String key);

    @Query(value = "SELECT RELEASE_LOCK(:key)", nativeQuery = true)
    void releaseLock(@Param("key") String key);
}

// Facade
@Service
@RequiredArgsConstructor
public class TicketFacadeWithNamedLock {
    private final TicketRepository ticketRepository;
    private final TicketServiceWithNamedLock ticketServiceWithNamedLock;

    public void buy(String ticketName) {
        ticketRepository.getLock(ticketName);

        try {
            ticketServiceWithNamedLock.buy(ticketName);
        } finally {
            ticketRepository.releaseLock(ticketName);
        }
    }
}

// Service
@Service
@RequiredArgsConstructor
public class TicketServiceWithNamedLock {
    private final TicketRepository ticketRepository;

    @Transactional
    public void buy(String ticketName) {
        // 1. get Ticket
        Ticket ticket = ticketRepository.findByName(ticketName);

        // 2. buy
        ticket.buyTicket();

        // 3. logging remain tickets
        TicketHelper.loggingTicketBuyProcess(ticket);
    }
}
```
![image](https://github.com/sjiwon/wanted-pre-onboarding-challenge-be-task-July/assets/51479381/b49a545e-8b05-448b-bd68-0d729f6560bd)

- MySQLì—ì„œëŠ” `GET_LOCK & RELEASE_LOCK`ì„ í†µí•´ì„œ Named Lockì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤

<br>

## Distributed Lock (Redis)
> Race Conditionì´ ë°œìƒí–ˆì„ ê²½ìš° í•˜ë‚˜ì˜ ê³µìœ  ìì›ì— ì ‘ê·¼í•  ë•Œ ë°ì´í„° ë¶ˆì¼ì¹˜ê°€ ë°œìƒí•˜ì§€ ì•Šë„ë¡ `Atomic`ì„ ë³´ì¥í•˜ëŠ” ê¸°ë²•

- ëŒ€í‘œì ìœ¼ë¡œ In-Memory DB/Cacheë¡œì¨ Single Threadë¡œ ë™ì‘í•˜ëŠ” Redisë¥¼ í†µí•´ì„œ ë¶„ì‚°ë½ì„ êµ¬í˜„í•  ìˆ˜ ìˆë‹¤

### Lettuce Client
- Spring Data Redisì˜ ê¸°ë³¸ êµ¬í˜„ì²´

```java
@Repository
@RequiredArgsConstructor
public class RedisLettuceClientLockRepository {
    private final RedisTemplate<String, String> redisTemplate;

    public Boolean lock(String key) {
        return redisTemplate
                .opsForValue()
                .setIfAbsent(key, "lock", Duration.ofMillis(3_000));
    }

    public Boolean unlock(String key) {
        return redisTemplate.delete(key);
    }
}
```
- `setnx` ëª…ë ¹ì–´ë¥¼ í†µí•´ì„œ Lockì„ ê´€ë¦¬í•œë‹¤
  - `SET if Not eXists`
    - íŠ¹ì • Keyì— ëŒ€í•œ Valueê°€ ì¡´ì¬í•˜ì§€ ì•Šì„ ê²½ìš°ë§Œ ê°’ì„ ì„¤ì •í•  ìˆ˜ ìˆë‹¤
- `setnx`ëŠ” `Spin Lock` í˜•ì‹ìœ¼ë¡œ Lockì„ íšë“í•˜ë ¤ê³  ì‹œë„í•˜ê¸° ë•Œë¬¸ì— ì“°ë ˆë“œê°€ ë§ìœ¼ë©´ ë§ì„ìˆ˜ë¡ Redisì— ê°€í•´ì§€ëŠ” ë¶€í•˜ê°€ ì‹¬í•´ì§„ë‹¤

```java
// Facade
@Service
@RequiredArgsConstructor
public class TicketFacadeWithRedisLettuceClientLock {
    private final RedisLettuceClientLockRepository redisLettuceClientLockRepository;
    private final TicketServiceWithRedisLettuceClientLock ticketServiceWithRedisLettuceClientLock;

    public void buy(String ticketName) throws InterruptedException {
        while (!redisLettuceClientLockRepository.lock(ticketName)) {
            TicketHelper.loggingRedisDistributedLockByLettuceClient();
            Thread.sleep(50); // Spin Lock ë¶€í•˜ë¥¼ ì¤„ì´ê¸° ìœ„í•´ì„œ 50ms ëŒ€ê¸° í›„ ë‹¤ì‹œ Lock íšë“ ì‹œë„
        }

        try {
            ticketServiceWithRedisLettuceClientLock.buy(ticketName);
        } finally {
            redisLettuceClientLockRepository.unlock(ticketName);
        }
    }
}

// Service
@Service
@RequiredArgsConstructor
public class TicketServiceWithRedisLettuceClientLock {
    private final TicketRepository ticketRepository;

    @Transactional
    public void buy(String ticketName) {
        // 1. get Ticket
        Ticket ticket = ticketRepository.findByName(ticketName);

        // 2. buy
        ticket.buyTicket();

        // 3. logging remain tickets
        TicketHelper.loggingTicketBuyProcess(ticket);
    }
}
```
![image](https://github.com/sjiwon/wanted-pre-onboarding-challenge-be-task-July/assets/51479381/3eeae860-186f-4ae1-b578-0b356fe11e63)

### Redisson Client
`Spin Lock` ë©”ì»¤ë‹ˆì¦˜ì„ í†µí•´ì„œ Lockì„ íšë“í•˜ë ¤ê³  ì§€ì†ì ìœ¼ë¡œ Redisì— ë¶€í•˜ë¥¼ ì£¼ëŠ” Lettuce Clientì™€ëŠ” ë‹¬ë¦¬ `Redisson Client`ëŠ” `pub/sub` ë©”ì»¤ë‹ˆì¦˜ì„ í†µí•´ì„œ Lockì„ íšë“í•˜ë ¤ê³  ì‹œë„í•œë‹¤
- Spin Lockê³¼ ë‹¬ë¦¬ ì§€ì†ì ìœ¼ë¡œ Redisì— ë¶€í•˜ë¥¼ ì£¼ì§€ ì•Šê³  íŠ¹ì • ì“°ë ˆë“œê°€ Lockì„ ë°˜ë‚©í•  ê²½ìš° í•´ë‹¹ ì±„ë„ì„ subscribeí•˜ëŠ” channelì—ê²Œ ì „ë¶€ ì•Œë ¤ì„œ í•´ë‹¹ channelì˜ íŠ¹ì • ì“°ë ˆë“œê°€ Lockì„ íšë“í•  ìˆ˜ ìˆë‹¤

```java
// Facade
@Service
@RequiredArgsConstructor
public class TicketFacadeWithRedisRedissonClientLock {
    private final RedissonClient redissonClient;
    private final TicketServiceWithRedisRedissonClientLock ticketServiceWithRedisRedissonClientLock;

    public void buy(String ticketName) throws InterruptedException {
        RLock lock = redissonClient.getLock(ticketName);

        try {
            if (!lock.tryLock(5, 1, TimeUnit.SECONDS)) {
                return;
            }

            ticketServiceWithRedisRedissonClientLock.buy(ticketName);
        } finally {
            if (lock.isLocked() && lock.isHeldByCurrentThread()) {
                lock.unlock();
            }
        }
    }
}

// Service
@Service
@RequiredArgsConstructor
public class TicketServiceWithRedisRedissonClientLock {
    private final TicketRepository ticketRepository;

    @Transactional
    public void buy(String ticketName) {
        // 1. get Ticket
        Ticket ticket = ticketRepository.findByName(ticketName);

        // 2. buy
        ticket.buyTicket();

        // 3. logging remain tickets
        TicketHelper.loggingTicketBuyProcess(ticket);
    }
}
```
![image](https://github.com/sjiwon/wanted-pre-onboarding-challenge-be-task-July/assets/51479381/74f7bc73-68ca-4963-b17d-63ab0d989869)

